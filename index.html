<!doctype html>
<html lang="de">
<head>
  <script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyA_IPMf3X1PABrfMlrpgT0tMCTeQVnhLUs",
    authDomain: "jumpandrunhighscore.firebaseapp.com",
    databaseURL: "https://jumpandrunhighscore-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "jumpandrunhighscore",
    storageBucket: "jumpandrunhighscore.firebasestorage.app",
    messagingSenderId: "770421489723",
    appId: "1:770421489723:web:8bc433474dae3d7d5edc1e",
    measurementId: "G-SJD78YNJK0"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
    
    let playerName = prompt("Bitte gib deinen Namen ein:", "Spieler") || "Spieler";

    function saveOnlineHighscore(score) { 
  
  push(ref(db, 'scores/'), { name: playerName, score: Math.floor(score) });
}
if(gameOver) saveOnlineHighscore(score);

    <div class="panel" id="leaderboard">Highscores werden geladen...</div>

    async function updateLeaderboard() {
  const topScores = query(ref(db, 'scores/'), orderByChild('score'), limitToLast(10));
  const snapshot = await get(topScores);
  const scores = [];
  snapshot.forEach(child => scores.push(child.val()));
  scores.sort((a,b)=>b.score-a.score);
  const board = document.getElementById('leaderboard');
  board.innerHTML = scores.map(s => s.name === playerName ? `<b>${s.name}: ${s.score}</b>` : `${s.name}: ${s.score}`).join('<br>');
}
setInterval(updateLeaderboard, 3000);

</script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Unendliches Jump & Run</title>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    html,body{height:100%;margin:0;background:#87CEEB;}
    #gameWrap{display:flex;flex-direction:column;height:100vh;align-items:center;justify-content:center}
    canvas{background:linear-gradient(#87CEEB,#6FC3F0);border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,0.15)}
    .hud{position:relative;margin-top:12px;display:flex;gap:12px;align-items:center}
    .panel{background:rgba(255,255,255,0.9);padding:8px 12px;border-radius:8px;font-weight:600}
    .controls{font-size:13px;color:#333}
    button{padding:8px 12px;border-radius:8px;border:0;background:#1f8ef1;color:white;font-weight:700}
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" width="900" height="420"></canvas>

    <div class="hud">
      <div class="panel">Score: <span id="score">0</span></div>
      <div class="panel">Highscore: <span id="highscore">0</span></div>
      <div class="controls">Tasten: Leertaste / Klick / Tippen zum Springen • R zum Neustart</div>
      <button id="pauseBtn">Pause</button>
    </div>
  </div>

  <script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = canvas.width, H = canvas.height;

  function scaleForDPI() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  scaleForDPI();

  let running = true;
  let gameOver = false;
  let paused = false;

  const player = {
    x: 120,
    y: 0,
    w: 44,
    h: 60,
    vy: 0,
    jumpPower: -13,
    grounded: false,
    color: '#ff6b6b',
    animFrame: 0,
  };

  const ground = { y: H - 80, height: 80 };

  let obstacles = [];
  let spawnTimer = 0;
  let spawnInterval = 90;

  let baseSpeed = 5;
  let speed = baseSpeed;
  let distance = 0;

  let score = 0;
  const scoreEl = document.getElementById('score');
  const highscoreEl = document.getElementById('highscore');
  const HS_KEY = 'infinite-jr-highscore-v1';
  let highscore = parseInt(localStorage.getItem(HS_KEY) || '0', 10);
  highscoreEl.textContent = highscore;

  let wantJump = false;

  function resetGame() {
    obstacles = [];
    spawnTimer = 0;
    spawnInterval = 90;
    baseSpeed = 5;
    speed = baseSpeed;
    distance = 0;
    score = 0;
    gameOver = false;
    player.y = ground.y - player.h;
    player.vy = 0;
    player.grounded = true;
    player.animFrame = 0;
  }

  resetGame();

  function randRange(a,b){return Math.random()*(b-a)+a}

  function spawnObstacle(){
    // kleinere Blöcke erzeugen
    const h = Math.round(randRange(20, 50));
    const w = Math.round(randRange(18, 36));
    const y = ground.y - h;
    obstacles.push({x: W + 20, y, w, h, passed: false, color: '#2d3436'});
  }

  function collides(a,b){
    const buffer = 8;
    return a.x + buffer < b.x + b.w && a.x + a.w - buffer > b.x && a.y + buffer < b.y + b.h && a.y + a.h - buffer > b.y;
  }

  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space') { e.preventDefault(); wantJump = true; }
    if(e.key === 'r' || e.key === 'R') { if(gameOver) resetGame(); }
    if(e.key === 'p' || e.key === 'P') togglePause();
  });
  window.addEventListener('keyup', (e)=>{ if(e.code === 'Space') wantJump = false; });

  canvas.addEventListener('mousedown', (e)=>{ wantJump = true; setTimeout(()=>wantJump=false,100); });
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); wantJump = true; setTimeout(()=>wantJump=false,150); }, {passive:false});

  document.getElementById('pauseBtn').addEventListener('click', togglePause);

  function togglePause(){ paused = !paused; document.getElementById('pauseBtn').textContent = paused? 'Fortsetzen' : 'Pause'; }

  let frame = 0;
  function update(){
    if(paused || gameOver) return;
    frame++;

    if(frame % 300 === 0) { baseSpeed += 0.3; }
    speed = baseSpeed + Math.floor(frame/600)*0.4;

    const gravity = 0.7;
    if(wantJump && player.grounded){ player.vy = player.jumpPower; player.grounded = false; }
    player.vy += gravity;
    player.y += player.vy;

    if(player.y + player.h >= ground.y){ player.y = ground.y - player.h; player.vy = 0; player.grounded = true; }

    spawnTimer++;
    if(spawnTimer >= spawnInterval){
      spawnObstacle();
      spawnTimer = 0;
      spawnInterval = Math.max(50, Math.round(randRange(60, 140) - frame*0.02));
    }

    for(let i = obstacles.length-1; i >= 0; i--){
      const ob = obstacles[i];
      ob.x -= speed;
      if(!ob.passed && ob.x + ob.w < player.x){ ob.passed = true; score += 10; }
      if(ob.x + ob.w < -50) obstacles.splice(i,1);
      if(collides(player, ob)) { gameOver = true; running = false; saveHighscore(); }
    }

    distance += speed * 0.016;
    score += 0.02 * speed;

    scoreEl.textContent = Math.floor(score);
    frame = frame;
  }

  function saveHighscore(){
    const s = Math.floor(score);
    if(s > highscore){ highscore = s; localStorage.setItem(HS_KEY, highscore); highscoreEl.textContent = highscore; }
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    drawBackground();

    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(0, ground.y, W, ground.height);

    for(let i=0;i<6;i++){
      const x = ((frame*speed*0.5) + i*220) % (W+220) - 220;
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.fillRect(x, ground.y + 10, 120, 8);
    }

    for(const ob of obstacles){
      ctx.fillStyle = ob.color;
      roundRect(ctx, ob.x, ob.y, ob.w, ob.h, 6, true, false);
    }

    drawPlayer();

    if(gameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = 'white';
      ctx.font = 'bold 36px system-ui,Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', W/2, H/2 - 10);
      ctx.font = '18px system-ui,Arial';
      ctx.fillText('Drücke R zum Neustart oder klicke zum spielen', W/2, H/2 + 28);
    }
  }

  function drawBackground(){
    ctx.save();
    ctx.translate(0,0);
    ctx.fillStyle = '#9AD36B';
    ctx.beginPath();
    ctx.ellipse(W*0.2 - (frame*0.2)%W, ground.y+20, 420, 110, 0, Math.PI, 2*Math.PI);
    ctx.ellipse(W*0.8 - (frame*0.2)%W, ground.y+40, 380, 100, 0, Math.PI, 2*Math.PI);
    ctx.fill();
    ctx.restore();
  }

  function drawPlayer(){
    ctx.fillStyle = player.color;
    roundRect(ctx, player.x, player.y, player.w, player.h, 8, true, false);

    const t = Date.now()/120;
    const legOffset = player.grounded ? Math.sin(t)*6 : Math.sin(t/4)*2;
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(player.x + 12, player.y + player.h);
    ctx.lineTo(player.x + 12 + legOffset, player.y + player.h + 18);
    ctx.moveTo(player.x + player.w - 12, player.y + player.h);
    ctx.lineTo(player.x + player.w - 12 - legOffset, player.y + player.h + 18);
    ctx.stroke();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  let last = 0;
  function loop(ts){
    if(!last) last = ts;
    const dt = ts - last;
    last = ts;

    if(!paused){
      const step = 1000/60;
      let accumulator = dt;
      while(accumulator > 0){ update(); accumulator -= step; }
    }

    draw();
    if(!gameOver) requestAnimationFrame(loop);
    else { saveHighscore(); draw(); }
  }

  requestAnimationFrame(loop);

  window.addEventListener('resize', ()=>{
    const wrap = document.getElementById('gameWrap');
    const maxW = Math.min(window.innerWidth - 40, 1000);
    const maxH = Math.min(window.innerHeight - 120, 560);
    const aspect = W / H;
    let newW = Math.min(maxW, Math.round(maxH * aspect));
    let newH = Math.round(newW / aspect);
    canvas.style.width = newW + 'px';
    canvas.style.height = newH + 'px';
  });

  player.y = ground.y - player.h;

  canvas.addEventListener('dblclick', ()=>{ if(gameOver) resetGame(); });
  canvas.addEventListener('click', ()=>{ if(gameOver) resetGame(); });

  document.body.addEventListener('touchstart', (e)=>{ if(e.target === canvas) e.preventDefault(); }, {passive:false});

  </script>
</body>
</html>
